% content_for 'additional_javascript' => begin
<script type="text/javascript">
	$(document).ready(function(){
		//websocket
		ws = new WebSocket('ws://localhost:3000/dispatch');
		ws.onopen = function(){
			//initialization
			var init_data = {
				'action': 'init',
				'data': {
					'pid': '<%= session('character_id') %>'
				}
			};
			ws.send(JSON.stringify(init_data));
		}

		ws.onerror = function(error){
			console.log('Error detected: ' + error);
		}
		
		ws.onmessage = function(e){
			var server_message = e.data;
			console.log(server_message);
		}

		Dispatcher = {
			'Entities': [],
			register: function(data){
				this.Entities.push(data);
			},
			execute_abilities: function(data){
				//this function will loop through all registered entities and check for abilities/actions that should affect the current entity
				var object1 = {
					'x': data.Entity.get_x(),
					'y': data.Entity.get_y()
				};
				for(var i=0; i < Dispatcher.Entities.length; i++){
					if(window[Dispatcher.Entities[i]].get_name() !== data.Entity.get_name()){
						var object2 = {
							'x': window[Dispatcher.Entities[i]].get_x(),
							'y': window[Dispatcher.Entities[i]].get_y()
						};
						var distance = UI.check_distance(object1,object2);
						for(var counter = 0; counter < window[Dispatcher.Entities[i]].abilities.length; counter++){
							//the following line is a bit ridiculous.  it pulls the range information out of the abilities array
							//first it must find the abilities tied to the entity
							if(window[Dispatcher.Entities[i]].abilities[counter].get_range > distance){
								var direction = '';
								var part1 = 'north';
								var part2 = 'west';
								if(data.Entity.get_x() > Dispatcher.Entities[i].get_x()){
									part2 = 'east';
								} else if(data.Entity.get_x() === Dispatcher.Entities[i].get_x()){
									part2 = '';
								}
								if(data.Entity.get_y() < Dispatcher.Entities[i].get_y()){
									part1 = 'south';
								} else if(data.Entity.get_y() === Dispatcher.Entities[i].get_y){
									part1 = '';
								}
								direction = part1 + part2;
								var info = {
									'distance': distance,
									'target': data.Entity.get_dom(),
									'attacker': Dispatcher.Entities[i].get_dom(),
									'direction': direction,
									'animation_offset_x': window[Dispatcher.Entities[i]].abilities[counter].animation_offset_x,
									'animation_offset_y': window[Dispatcher.Entities[i]].abilities[counter].animation_offset_y,
									'spell_entry_id': window[Dispatcher.Entities[i]].abilities[counter].get_id()
								};
								UI.animateAction(info);
							}
						}
					}
				}
			}
		};
		
		UI = {
			refresh: function(data){
			
			},
			move: function(data){//jqO = jquery Object
				var jqO = data.Entity.get_dom();
				if(!UI.collision(data)){
					if(data.direction === 'right' || data.direction === 'left'){
						jqO.animate({
							left: data.distance
						}, 500, function(){
							data.Entity.set_offset(jqO.offset());
							if(data.direction === 'right'){
								data.Entity.set_x(data.Entity.get_x() + 1);
								data.Entity.increment_tile(1);
							} else {
								data.Entity.set_x(data.Entity.get_x() - 1);
								data.Entity.increment_tile(-1);
							}
						});
					}
					if(data.direction === 'up' || data.direction === 'down'){
						jqO.animate({
							top: data.distance
						}, 500, function(){
							data.Entity.set_offset(jqO.offset());
							if(data.direction === 'up'){
								data.Entity.set_y(data.Entity.get_y() + 1);
								data.Entity.increment_tile(-tiles_x);
							} else {
								data.Entity.set_y(data.Entity.get_y() - 1);
								data.Entity.increment_tile(tiles_x);
							}
						});
					}
					Dispatcher.execute_abilities(data);
					ws.send(JSON.stringify({'data': data, 'action': 'move'}));
				}
			},
			collision: function(data){
				if(data.direction === 'up'){
					if(!collision_data[data.Entity.get_current_tile() - tiles_x] && data.Entity.get_offset_y() - 1 > map_offset.top){
						return false;
					} else {
						return true;
					}
				}
				if(data.direction === 'down'){
					if(!collision_data[data.Entity.get_current_tile() + tiles_x] && (data.Entity.get_offset_y() + tile_size_y) + 1 < map_offset.top + (tiles_y * tile_size_y)){
						return false;
					} else {
						return true;
					}
				}
				if(data.direction === 'left'){
					if(!collision_data[data.Entity.get_current_tile() - 1] && (data.Entity.get_offset_x() - 1) > map_offset.left){
						return false;
					} else {
						return true;
					}
				}
				if(data.direction === 'right'){
					if(!collision_data[data.Entity.get_current_tile() + 1] && (data.Entity.get_offset_x() + tile_size_x) + 1 < map_offset.left + (tiles_x * tile_size_x)){
						return false;
					} else {
						return true;
					}
				}
			},
			animateAction: function(data){
				var origin = {
					'top': 0,
					'left': 0
				};
				var target_offset = data.target.offset;
				var attacker_offset = data.attacker.offset;
				if(data.direction == 'west' || data.direction == 'northwest' || data.direction == 'southwest'){
					$('#map').append('<div class="animation" id="' + data.spell_entry_id + '" style="background-position: ' + data.animation_offset_x + 'px ' + animation_offset_y + 'px; top: ' + attack_offset.top + 'px; left: ' + attacker_offset.left - 32 + 'px;"></div>')
				}
				if(data.direction == 'east' || data.direction == 'northeast' || data.direction == 'southeast'){
					$('#map').append('<div class="animation" id="' + data.spell_entry_id + '" style="background-position: ' + data.animation_offset_x + 'px ' + animation_offset_y + 'px; top: ' + attack_offset.top + 'px; left: ' + (+attacker_offset.left + 32) + 'px;"></div>')
				}
				if(data.direction == 'north'){
					$('#map').append('<div class="animation" id="' + data.spell_entry_id + '" style="background-position: ' + data.animation_offset_x + 'px ' + animation_offset_y + 'px; top: ' + (+attack_offset.top + 32) + 'px; left: ' + attacker_offset.left + 'px;"></div>')
				}
				if(data.direction == 'north'){
					$('#map').append('<div class="animation" id="' + data.spell_entry_id + '" style="background-position: ' + data.animation_offset_x + 'px ' + animation_offset_y + 'px; top: ' + attack_offset.top - 32 + 'px; left: ' + attacker_offset.left + 'px;"></div>')
				}
				
				var animation_offest = $('#' + data.spell_entry_id).offset;
				while(animation_offest.left != target_offeset.left && animation_offest.top != target_offeset.top){
					if(data.direction == 'west'){
						animation_offset.left--;
					}
					if(data.direction == 'northwest'){
						animation_offset.top--;
						animation_offset.left--;
					}
					if(data.direction == 'southwest'){
						animation_offset.top++;
						animation_offset.left--;
					}
					if(data.direction == 'north'){
						animation_offset.top++;
					}
					if(data.direction == 'south'){
						animation_offset.top--;
					}
					if(data.direction == 'east'){
						animation_offset.left++;
					}
					if(data.direction == 'northeast'){
						animation_offset.top--;
						animation_offset.left++;
					}
					if(data.direction == 'southeast'){
						animation_offset.top++;
						animation_offset.left++;
					}
					$('#' + data.spell_entry_id).offset({top: animation_offest.top, left: animation_offset.left});
				}
			},
			check_distance: function(object1,object2){
				var distance = Math.sqrt(Math.pow((object2.x - object1.x),2) + Math.pow((object2.y - object2.y),2));
				return Math.abs(distance);
			}
		};

		Abilities = {
			'Abilities': [],
			register: function(data){
				this.Abilities.push(data);
			}
		};
		
		function Ability(uuid,r,d,c,n){
			this.id = uuid,
			this.range = r,
			this.damage = d,
			this.cast_time = c,
			this.name = n,
			this.set_name = function(data){
				this.name = data;
			},
			this.get_range = function(data){
				return this.range;
			},
			this.get_id = function(data){
				return this.uuid;
			}
		};

		Ability.prototype = new Ability();

		function Entity() {
			this.id = 0;
			this.hp = 0;
			this.mana = 0;
			this.x = 1;
			this.y = 1;
			this.offset = null;
			this.alive = 1;
			this.sprite = {
				x: 0,
				y: 0
			};
			this.current_tile = 1;
			this.current_map = 1;
			this.domElement = null;
			this.name = '';
			this.abilities = [];
		};
		Entity.prototype = {
			move_x: function(data){

			},
			move_y: function(data){
			
			},
			adjustStatus: function(data){
			
			},
			adjustStats: function(data){
			
			},
			set_offset: function(data){
				if(typeof data === 'undefined' || data === null){
					this.offset = this.domElement.offset();
				} else {
					this.offset = data;
				}
			},
			set_x: function(data){
				this.x = data;
			},
			set_y: function(data){
				this.y = data;
			},
			get_offset_x: function(data){
				return this.offset.left;
			},
			get_offset_y: function(data){
				return this.offset.top;
			},
			get_x: function(data){
				return this.x;
			},
			get_y: function(data){
				return this.y;
			},
			get_dom: function(){
				return this.domElement;
			},
			increment_tile: function(data){
				this.current_tile += data;
			},
			get_current_tile: function(data){
				return this.current_tile;
			},
			set_id: function(data){
				this.id = data;
			},
			set_map: function(data){
				this.current_map = data;
			},
			get_map: function(){
				return this.current_map;
			},
			set_current_tile: function(data){
				this.current_tile = data;
			},
			get_name: function(data){
				return this.name;
			},
			set_name: function(data){
				this.name = data;
			},
			register_ability: function(data){
				//data should be an object that includes information about the ability like range, damage, name, etc...
				this.abilities.push(data);
			}
		};

		function Character(o,name){
			this.items = {};
			this.domElement = o;
			this.set_name(name);
			window.Dispatcher.register(this.name);
		}
		
		Character.prototype = new Entity();
		Character.prototype.constructor = Character;
		
		//registering all abilities on the map
		% my $j = 1;
		% foreach my $ability (keys %{$spells}){
			ability<%= $j %> = new Ability('<%= $spells->{$ability}->{'spell_entry_id'} %>',<%= $spells->{$ability}->{'range'} %>,<%= $spells->{$ability}->{'damage'} %>,<%= $spells->{$ability}->{'cast_time'} %>,'<%= $spells->{$ability}->{'name'} %>');
			% $j++;
		% }
		
		% my $i = 1;
		% foreach my $character (@{$characters}){
			% if(session('character_id') eq $character->{'id'}){
				player = new Character($('.player'),'player');
				player.set_id('<%= session('character_id') %>');
				player.set_map('<%= stash('map_id') %>');
				player.set_x(<%= $character->{'x'} %>);
				player.set_y(<%= $character->{'y'} %>);
				player.set_offset();
				player.set_current_tile(<%= $character->{'tile_id'} %>);
				
				% foreach my $ability (@{$spell_mappings->{$character->{'id'}}->{'abilities'}}){
				player.register_ability(<%= $ability %>);
				% }
			% } else {
				character<%= $i %> = new Character($('.entity,pid=<%= $character->{'id'} %>'),'character<%= $character->{'id'} %>' );
				character<%= $i %>.set_id('<%= $character->{'id'} %>');
				character<%= $i %>.set_x(<%= $character->{'x'} %>);
				character<%= $i %>.set_y(<%= $character->{'y'} %>);
				character<%= $i %>.set_offset();
				character<%= $i %>.set_current_tile(<%= $character->{'tile_id'} %>);
				% foreach my $ability (@{$spells->{$character->{'id'}}->{'abilities'}}){
				character<%= $i %>.register_ability(<%= $ability %>);
				% }
				% $i++;
			% }
		% }
		
		function NPC(o,name){
			this.domElement = o;
			this.set_name(name);
			window.Dispatcher.register(this.name);
		}
		
		NPC.prototype = new Entity;
		NPC.prototype.constructor = NPC;
		
		function CREATURE(o,name){
			this.domElement = o;
			this.set_name(name);
			window.Dispatcher.register(this.name);
		}
		
		CREATURE.prototype = new Entity;
		CREATURE.prototype.constructor = CREATURE;

		% $i = 1;
		% foreach my $npc (@{$npcs}){
		
			npc<%= $i %> = new NPC($("div[npc_id='<%= $npc->{'id'} %>']"),'npc<%= $i %>');
			
			//tieing abilities to npcs
			//placing a copy of an ability javascript object in the abilities array of the npc
			% foreach my $ability (keys %{$spell_mappings->{$npc->{'id'}}->{'abilities'}}){
			for(var counter = 0; counter < Abilities.Abilities.length; counter++){
				if(Abilities.Abilities[counter].get_id == '<%= $spell_mappings->{$npc->{'id'}}->{'abilities'}->{$ability}->{'spell_entry_id'} %>'){
					npc<%= $i %>.register_ability(Abilities.Abilities[counter]);
				}
			}
			% $i++;
			% }
		% }
		
		% $i = 1;
		% foreach my $creature (@{$creatures}){
			creature<%= $i %> = new CREATURE($("div[creature_id='<%= $creature->{'id'} %>']"),'creature<%= $i %>');
			//placing a copy of an ability javascript object in the abilities array of the creature
			% foreach my $ability (keys %{$spell_mappings->{$creature->{'id'}}->{'abilities'}}){
			for(var counter = 0; counter < Abilities.Abilities.length; counter++){
				if(Abilities.Abilities[counter].get_id == '<%= $spell_mappings->{$creature->{'id'}}->{'abilities'}->{$ability}->{'spell_entry_id'} %>'){
					creature<%= $i %>.register_ability(Abilities.Abilities[counter]);
				}
			}
			% $i++;
			% }
		% }
	});
</script>
% end